这个文档描述gRPC内的负载均衡设计。
# 背景
## 每调用的负载均衡
值得注意的是，gRPC内的负载平衡是基于每个调用而不是每个连接进行的。换句话说，即使所有请求都来自单个客户端，我们仍然希望在所有服务器之间实现负载平衡。
## 负载均衡的方法
在任何gRPC的规范之前，我们分析下一些用来做负载均衡的常规方式。
### 代理模式
使用代理可提供可靠的可靠客户端，可以将负载报告给负载平衡系统。
缺点：代理通常需要更多资源才能运行，因为它们有RPC请求和响应的临时副本。此模型还增加了RPC的延迟。

当考虑请求大量服务（例如存储）时，代理模型被认为效率低下。

### 感知平衡的Client
这个更厚的client放了更多的负载均衡逻辑在client中。  
例如，client可以包含一些负载均衡策略（例如，Round Robin，Random等等），用这些负载均衡策略从一个列表中选择server。在这个模型中，server的列表要么在client中静态配置，通过名字解析系统提供（一个外部的负载均衡器）。在任何情况下，客户端都负责从列表中选择首选服务器。

这种方法的缺点之一是以多种语言和/或客户端版本编写和维护负载平衡策略。这些策略非常复杂。一些算法也需要client到server的通信，这样client除了为用户请求发送RPC之外，就会变得更厚，以支持额外的RPC以获取健康或者负载信息。

这也会大大增加客户端代码的复杂性：新设计隐藏了多层负载平衡的复杂性，并将其作为简单的服务器列表呈现给客户端。

### 外部的负载均衡服务
client的负载均衡代码保持简单和可移植，实现了一些用来作为server选择的著名算法（例如，时间片轮转法）。复杂的负载均衡算法相反是由负载均衡器提供的。client依赖于负载均衡器来提供负载均衡配置和用来发送请求的server列表。平衡器根据需要更新服务器列表，以平衡负载以及处理服务器不可用或运行状况问题。负载均衡器将做出任何必要的复杂决定，并通知客户。负载平衡器可以与后端服务器通信以收集负载和健康信息。

# 需求
## 简单的API和client
gRPC客户端负载平衡代码必须简单且可移植。客户端应仅包含用于选择服务器的简单算法（例如Round Robin）。对于复杂的算法，客户端应依靠负载平衡器提供负载平衡配置以及客户端应向其发送请求的服务器列表。平衡器将根据需要更新服务器列表，以平衡负载以及处理服务器不可用或运行状况问题。负载均衡器将做出任何必要的复杂决定，并通知client。负载平衡器可以与后端服务器通信以收集负载和健康信息。
## 安全性
负载平衡器可能与实际的服务器后端分离，并且负载平衡器的危害仅应导致负载平衡功能的危害。换句话说，与没有负载平衡的可比情况相比，受到破坏的负载平衡器应该不能使客户端信任（可能是恶意的）后端服务器。

# 架构
## 概览
在gRPC中，主要的负载均衡机制是外部负载均衡，这种外部负载均衡器给简单的client提供实时更新的server列表。

gRPC客户端确实支持用于内置负载平衡策略的API。但是，其中只有少数（其中一个是grpclb策略，该策略实现了外部负载平衡），并且不鼓励用户尝试通过添加更多扩展gRPC。相反，应在外部负载均衡器中实施新的负载均衡策略。

## 工作流
在名字解析和与服务器的连接之间，负载平衡策略适合gRPC客户端工作流程。运作方式如下：

1. 在启动的时候，gRPC client为server名发起一个名字解析请求。名字被解析成一个或者多个IP地址。



# 参考资料
